# Batch styling of plots

{{< include ../_patterns.qmd >}}

```{r setup, include=FALSE, echo=FALSE}
library(intendo)
library(pointblank)
library(ggplot2)
library(gt)
library(dplyr)
library(tidyr)
library(glue)
library(patchwork)
```

## This Chapter's Pattern

We want to apply styling to different plots, but do it in a way that doesn't require us to type out all the different options each and every time. We'll do this by making styling functions that work with **ggplot2** and **gt**. To get this going, a dataset will be explored and we'll arbitrarily try out different forms of styling. Once we have plots that look good, the code will be developed into a reusable function. We want to be able to use that function consistently in our workflow, so, documentation will be written to explain what that function does and, importantly, how it is used.

## Explore

We're going to get some data from the **intendo** package. This data package contains synthetic datasets that deal with activity and revenue from an online game. The dataset we want for our examples is called `all_sessions` and that's accessed by using the `all_sessions()` function.

```{r}
#| output: false
#| echo: false
all_sessions <- intendo::all_sessions()
```

Let's have a quick look at the dataset using **dplyr**'s `glimpse()` function. This gives us an idea of what's contained in the dataset, even though we only see a small portion of it:

```{r}
dplyr::glimpse(all_sessions)
```

This dataset has lots of information on player sessions for an entire year. Our task is to create an effective visualization of player session length and revenue throughout the year. This will also our imagined stakeholders to make comparisons between engagement and revenue. 

Because there is so much data that can be plotted we will summarize the data to daily means of `session_duration`, revenue from in-app purchases (`rev_iap`), and revenue from ad views (`rev_ads`). This will be done with a little bit of **dplyr**:

```{r}
#| paged.print: false

session_revenue_summary <-
  all_sessions |>
  select(session_start, session_duration, rev_iap, rev_ads) |>
  mutate(day = lubridate::as_date(session_start)) |>
  group_by(day) |>
  summarize(
    mean_duration = mean(session_duration),
    mean_rev_iap = mean(rev_iap),
    mean_rev_ads = mean(rev_ads)
  )

session_revenue_summary
```

We want to develop a plot that shows the changes in these daily average over the entire `2015` year. We can start the process by making a basic plot with each of these variables having their own line:

```{r}
session_revenue_summary |>
  ggplot() +
  geom_line(aes(x = day, y = mean_duration)) +
  geom_line(aes(x = day, y = mean_rev_iap)) +
  geom_line(aes(x = day, y = mean_rev_ads))
```

While this is definitely not what we'd want as a final plot, it can certainly serve as a good exploratory plot. Two things are important to note:

1. duration and revenue lines shouldn't belong on the same *y* axis
2. the lowest of the three lines (representing `mean_rev_ads`) is small and probably insignificant

With both of these things in mind, we probably ought to split the visualization to show two plots: one for session duration and the other for daily revenue. Since ad revenue is small compared to revenue from in-app purchases (and fairly unchanging throughout the year), we could safely omit that from any future plotting.

The *x* axis *is* common to both the `mean_duration` and `mean_rev_iap` values that we'll carry forward. Owing to that, it makes sense to stack the plots vertically so that we can easily compare session duration and revenue values for the same time range. How do we do this? One great solution involves using the **patchwork** package.

```{r}
mean_duration_plt <-
  ggplot(session_revenue_summary) +
  geom_line(aes(x = day, y = mean_duration))

mean_rev_iap_plt <-
  ggplot(session_revenue_summary) +
  geom_line(aes(x = day, y = mean_rev_iap))

session_revenue_summary_plt <-
  mean_duration_plt / mean_rev_iap_plt

session_revenue_summary_plt
```

This looks a bit closer to what we need! We now can see these two plots are perfectly stacked such that the *x*-axis ticks line up vertically across both plots, regardless of what labeling is on the *y* axes. Because of this concordance, we might find that the *x*-axis labels don't need to be seen twice. So, let's remove all labels and tick marks from the upper plot.

```{r}
mean_duration_plt <-
  ggplot(session_revenue_summary) +
  geom_line(aes(x = day, y = mean_duration)) +
  theme(
    axis.ticks.x = element_blank(),
    axis.text.x = element_blank(),
    axis.title.x = element_blank()
  )

mean_rev_iap_plt <-
  ggplot(session_revenue_summary) +
  geom_line(aes(x = day, y = mean_rev_iap))

session_revenue_summary_plt <-
  mean_duration_plt / mean_rev_iap_plt

session_revenue_summary_plt
```

With that bit of plotting code, we've eliminated the unnecessary repetition of the *x*-axis `ticks`, `text`, and `title`.

## Understand

Now that we have the basic structuring of the two plots now in place, it would be interesting to plot average value lines for each of the plots. A good way to divide them up is by week. To do this, we need to go back to the `session_revenue_summary` table and make changes so that we have that data in separate columns (one for session duration and the other for revenue).

```{r}
#| paged.print: false

session_revenue_summary <-
  session_revenue_summary |>
  mutate(week = lubridate::week(day)) |>
  group_by(week) |>
  mutate(
    mean_duration_wk = mean(mean_duration),
    mean_rev_iap_wk = mean(mean_rev_iap)
  ) |>
  ungroup()

session_revenue_summary
```

In the above **dplyr** code, we are taking means of means. We needed first to have the week number in a new column, and **lubridate**'s `week()` function is perfect for that. Then, the next key combination was the use of `group_by()` and then `mutate()`. This lets us adds new columns of summarized data that belongs to each `week` category.

Now we can plot again, adding in the weekly average lines as separate layers via additional `geom_line()` statements:

```{r}
mean_duration_plt <-
  ggplot(session_revenue_summary) +
  geom_line(aes(x = day, y = mean_duration)) +
  geom_line(aes(x = day, y = mean_duration_wk)) +
  theme(
    axis.ticks.x = element_blank(),
    axis.text.x = element_blank(),
    axis.title.x = element_blank()
  )

mean_rev_iap_plt <-
  ggplot(session_revenue_summary) +
  geom_line(aes(x = day, y = mean_rev_iap)) +
  geom_line(aes(x = day, y = mean_rev_iap_wk))

session_revenue_summary_plt <-
  mean_duration_plt / mean_rev_iap_plt

session_revenue_summary_plt
```

The weekly average lines are now in the plots, so, this is progress! The next things to be done are to package this up in a better visualization, one that is better understood by others.

## Explain

We need to style this combined set of plots so that the results are more easily explainable to others.

```{r}
mean_duration_plt <-
  ggplot(session_revenue_summary) +
  geom_line(
    aes(x = day, y = mean_duration),
    color = "gray",
    alpha = 0.75
  ) +
  geom_line(
    aes(x = day, y = mean_duration_wk),
    color = "steelblue",
    linewidth = 1.5
  ) +
  labs(
    title = "Average daily session time and in-app revenue",
    subtitle = "All data shown for the 2015 year",
    x = NULL,
    y = "Average daily\n session time (min)"
  ) +
  theme_minimal() +
  theme(
    axis.ticks.x = element_blank(),
    axis.text.x = element_blank(),
    axis.title.x = element_blank()
  )

mean_rev_iap_plt <-
  ggplot(session_revenue_summary) +
  geom_line(
    aes(x = day, y = mean_rev_iap),
    color = "gray",
    alpha = 0.75
  ) +
  geom_line(
    aes(x = day, y = mean_rev_iap_wk),
    color = "green",
    linewidth = 1.5
  ) +
  labs(
    caption = "Data source: the 'all_sessions' data table.",
    x = NULL,
    y = "Average IAP\n revenue (USD)"
  ) +
  geom_line(aes(x = day, y = mean_rev_iap_wk)) +
  theme_minimal()
  
session_revenue_summary_plt <-
  mean_duration_plt / mean_rev_iap_plt

session_revenue_summary_plt
```

This plot definitely something that is presentable to others. One thing that would make this more amenable to sharing (and sharing more often) would be wrapping this all into a reusable function. In the next section, we'll do just that, allowing for different time spans to be chosen.

## Share

Demonstrate a few different ways to theme the plot.

- try using the `scale_kiki()` example from Hiroaki Yutani (code snippet available in a tweet of his) that uses a custom function called globally from `options()`
- `ggplot2::theme_set`
- using `ggthemer` and `thematic`
- use ideas from https://github.com/r-causal/causal-inference-in-R/blob/a060488e1368278bbe2f2af368d888034645d2e1/index.qmd#L75
- https://github.com/robjhyndman/ETC3550Slides/blob/4d2566efbb7bce72825b2a9a045d3b6a3a58e882/setup.R#L16
- for Quarto use either YAML `includes` or the include shortcode (great for talking about shortcodes in general)
